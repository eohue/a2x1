{
  "rules": [
    {
      "type": "prd",
      "content": "# Product Requirements Document  \n아이부키(ibookee) 홈페이지 리뉴얼\n\n## 1. Executive Summary\n현행 사이트는 아이부키의 사회주택 모델·커뮤니티 철학·운영 가치를 충분히 전달하지 못한다. 새 웹·포털·관리자 시스템을 통합 구축해 브랜드 인지도, 사용자 경험, 운영 효율을 동시에 향상시킨다.\n\n## 2. Problem Statement\n1. 정보 단편화: 회사 소개·프로젝트·입주 프로세스가 흩어져 있어 이해도 저하  \n2. 커뮤니티 기능 부재: 입주민 간 온라인 소통/자치 활동 채널 없음  \n3. 운영 비효율: 입주 승인·민원 처리·콘텐츠 게시가 수작업 중심  \n4. 브랜드 메시지 미흡: 기업 비전·사회적 임팩트가 시각화되지 않음\n\n## 3. Goals and Objectives\n- Primary Goal: “비전·프로젝트·커뮤니티·운영”을 하나로 묶은 통합 플랫폼 구축  \n- Secondary Goals  \n  - UX 개선: 목표 사용자별 맞춤 정보 & 간편 내비게이션  \n  - 커뮤니티 활성: 입주민 자발적 소통, 오프라인 활동 연계  \n  - 운영 자동화: 관리자 포털로 승인·공지·모더레이션 통합  \n- Success Metrics  \n  - Public Site 월 UV +50%, 입주 신청 전환율 3%↑  \n  - Resident Portal MAU 60% 이상, 주간 게시물 100건  \n  - 신규 입주 승인 평균 24h 이내, 민원 처리 48h 이내  \n\n## 4. Target Audience\n### Primary Users\n- 현재 입주민: 실시간 공지·소모임·생활가이드 편집\n### Secondary Users\n- 예비 입주민: 프로젝트·커뮤니티 분위기·입주 절차 파악, 신청\n### Tertiary Users\n- 외부 관심자·파트너·투자자: 사회주택 가치, 사업성과, ESG 자료\n### Internal\n- 운영 관리자: 회원·콘텐츠·리포트 중심 운영\n\n## 5. User Stories\n- 입주민: “공동체 소식을 한눈에 보고 댓글로 소통하고 싶다.”  \n- 예비 입주민: “입주 조건과 실제 거주 후기를 보고 온라인으로 신청하고 싶다.”  \n- 파트너: “아이부키의 사회적 성과 및 재무 지표를 확인하고 협업을 타진하고 싶다.”  \n- 관리자: “가입 요청·공지·민원을 대시보드에서 즉시 처리하고 싶다.”\n\n## 6. Functional Requirements\n### Core Features\n1. Public Site  \n   - 히어로 섹션: 비전·임팩트 지표 시각화  \n   - Projects: 필터·검색, 상세 페이지 + 기획서 PDF 다운로드  \n   - Community Preview: 인스타 피드·입주민 인터뷰  \n   - 입주 신청: 공고 게시, 조건 안내, 온라인 폼, FAQ, 1:1 문의\n2. Resident Portal  \n   - 인증 기반 로그인/가입(관리자 승인)  \n   - Dashboard: 개인화 알림·공지  \n   - Community Feed: 글/사진/영상, 소모임 채널, 인스타·카톡 연동  \n   - Living Guide: 위키형 편집, 관리자 승인 워크플로우  \n   - Event & Poll: 일정, 투표, 모임 생성·참여\n3. Admin Portal  \n   - 역할: Super, Hub, House Manager  \n   - 통합 대시보드: 회원·활성도·민원·콘텐츠 현황  \n   - 회원 관리: 승인·검색·권한·퇴거 처리  \n   - 콘텐츠 관리: 프로젝트·뉴스·공지·모더레이션  \n   - 리포트: MAU, 게시물, 민원 처리, CSV/PDF 다운로드\n\n### Supporting Features\n- 푸시 알림(Firebase)  \n- 다국어(한국어/영어) 구조 설계  \n- SEO & SNS Meta 태그 자동 생성  \n- 접근성 준수(WCAG 2.1 AA)  \n\n## 7. Non-Functional Requirements\n- Performance: 핵심 페이지 LCP 2.5s 이내, P95 API 500ms 이하  \n- Security: OAuth2, JWT, HTTPS, 개인정보 암호화(At-rest AES256)  \n- Usability: 모바일 우선, 반응형, 키보드 내비게이션  \n- Scalability: 멀티테넌트 주택 단지 추가, Kubernetes 자동 확장  \n- Compatibility: 최신 Chrome, Safari, Edge, Android/iOS 2버전 이하 지원\n\n## 8. Technical Considerations\n- Frontend: Next.js 14, React, Tailwind CSS, TypeScript  \n- Backend: Node.js (NestJS), PostgreSQL, Redis, Socket.io  \n- Infra: AWS (EKS, RDS, S3, CloudFront), Terraform IaC  \n- Integrations: Instagram Graph API, 카카오톡 공유, Firebase FCM, 결제 PG (NICEPay)  \n- Data: ERD - User, House, Post, Comment, Event, Application, Report 등  \n- CI/CD: GitHub Actions → ECR → EKS Blue/Green 배포\n\n## 9. Success Metrics and KPIs\n- UV, PV, 신청 전환율, SEO Score  \n- MAU/DAU, 게시글·댓글·모임 수, 푸시 열람률  \n- 평균 승인/민원 처리 시간, 관리자 NPS  \n- 서버 가동률 99.9%, 오류율 <0.1%\n\n## 10. Timeline and Milestones\n- Phase 1 (M+2): 디자인 시스템, Public Site MVP, Resident 로그인/피드, Admin 기본  \n- Phase 2 (M+4): Living Guide, 이벤트·투표, 푸시, 인스타 자동 연동  \n- Phase 3 (M+6): 다주택 교류, 리포트 자동화, 권한 세분화  \n- Phase 4 (M+9): 모바일 앱 조사·POC, 외부 회계 API, 개인화 추천\n\n## 11. Risks and Mitigation\n- Instagram API 변경 → RSS 백업·크롤링 대체 경로 마련  \n- 데이터 유출 → 정기 펜테스트·암호화·권한 최소화  \n- 커뮤니티 저활성 → 오프라인 행사 연계, 초기 콘텐츠 시드 확보  \n- 일정 지연 → 애자일 2주 스프린트, 버퍼 10%\n\n## 12. Future Considerations\n- iOS/Android 하이브리드 앱  \n- ESG 임팩트 리포트 자동 생성  \n- 스마트 락/IoT 연동으로 시설 예약·출입 관리  \n- AI 챗봇 민원 대응 및 콘텐츠 추천\n\n(문서 길이: 약 6,300자)",
      "writedAt": "2025-06-25T11:36:37.116Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  - Public Site·Resident Portal·Admin Portal을 하나의 모노레포(Frontend/Backend 분리)로 통합 구축한다.  \n  - CSR/SSR 하이브리드(Next.js 14) 및 NestJS 기반 BFF 구조를 채택하여 UX·SEO·성능을 모두 충족한다.\n- **핵심 기술 스택**  \n  - Frontend: Next.js 14, React 18, TypeScript, Tailwind CSS, Shadcn UI, Zustand  \n  - Backend: Node.js 20, NestJS 10, PostgreSQL 15, Redis 7, Socket.io, TypeORM  \n  - Infra: AWS EKS, RDS, S3, CloudFront, Terraform IaC, GitHub Actions CI/CD\n- **주요 기술 목표**  \n  - LCP ≤ 2.5 s, P95 API ≤ 500 ms, 서버 가동률 99.9%  \n  - Kubernetes HPA로 트래픽 3배 급등 시 5분 내 자동 확장  \n  - 역할 기반 접근제어(RBAC)·AES256 암호화·OWASP Top10 대비\n- **핵심 가정**  \n  - 예상 동시접속 2k, 월 UV 100k 기준으로 초기 인프라 설계  \n  - 멀티테넌트 주택 단지 추가를 위한 하드·소프트 파티셔닝 병행  \n  - SaaS형 외부 서비스(FCM, Instagram API, NICEPay)의 가용성 99% 이상\n\n## 2. Technology Stack Architecture\n### Frontend Technology Stack\n| 영역 | 선택 기술 | 비고 |\n|------|----------|------|\n| Core Framework | Next.js 14 (App Router) | ISR + SSG + SSR 혼합 |\n| State Management | Zustand + React Context | RTK 미사용, 경량 관리 |\n| Routing & Navigation | Next.js 내장 Router | 동적 세그먼트·국제화(i18n) |\n| UI/UX Framework | Tailwind CSS + Shadcn UI + Lucide Icons | 디자인 시스템 기반 |\n| Build Tools | Vite 불사용, Next.js 내장 Turbopack | ESLint, Prettier, Husky |\n\n### Backend Technology Stack\n| 영역 | 선택 기술 | 비고 |\n|------|----------|------|\n| Runtime | Node.js 20 (LTS) | ES Module |\n| Web Framework | NestJS 10 (Express Adapter) | DI·모듈화 |\n| API Design | REST + WebSocket | Swagger(OpenAPI) 자동화 |\n| Data Validation | class-validator + Zod | DTO 검증 일원화 |\n| Middleware | Helmet, RateLimiter, morgan | 로깅·보안·트래픽 제어 |\n\n### Database & Persistence Layer\n| 항목 | 내용 |\n|------|------|\n| Primary DB | PostgreSQL 15 (AWS RDS) |\n| Schema Design | 3NF 준수, 멀티테넌트용 tenant_id 파티션 |\n| Caching | Redis 7 (AWS ElastiCache) — 세션·열람수·퀴즈 |\n| Migration | TypeORM Migration CLI, GitOps 관리 |\n| Backup & Recovery | RDS 자동 스냅샷(30일) + 월간 S3 Glacier |\n\n### Infrastructure & DevOps\n| 항목 | 내용 |\n|------|------|\n| Hosting | AWS EKS(Fargate) + ALB + CloudFront |\n| Containerization | Dockerfile(Multi-Stage) + Helm 차트 |\n| CI/CD | GitHub Actions → ECR → Argo Rollouts(Blue/Green) |\n| Monitoring | Prometheus + Grafana + Loki, Sentry |\n| Logging | Fluent Bit → OpenSearch(ELK 호환) |\n\n## 3. System Architecture Design\n### Top-Level Building Blocks\n- Frontend Web  \n  - Public Site, Resident Portal, Admin UI  \n- API Gateway / BFF  \n  - NestJS 앱, REST & WebSocket, Auth, Rate Limiting  \n- Core Microservices  \n  - User, Community, Project, Application, Reporting  \n- Data Stores  \n  - PostgreSQL, Redis, S3(파일), CloudFront(CDN)  \n- External Integrations  \n  - Firebase FCM, Instagram Graph API, Kakao Share, NICEPay  \n- DevOps & Observability  \n  - GitHub Actions, ArgoCD, Prometheus, Grafana, Loki\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    FE[Next.js Frontend] -->|HTTPS| BFF[NestJS API Gateway]\n    BFF -->|gRPC/REST| MS[(Microservices)]\n    MS -->|SQL| DB[(PostgreSQL)]\n    MS -->|Cache| REDIS[(Redis)]\n    BFF -->|WebSocket| FE\n    BFF -->|REST| EXT[External APIs]\n```\n- FE는 CSR/SSR 요청을 BFF로 전달하며 SEO 페이지는 SSR로 렌더링  \n- BFF는 인증·권한 체크 후 마이크로서비스에 요청 프록시  \n- 마이크로서비스는 PostgreSQL 및 Redis와 상호작용, 이벤트를 WebSocket으로 Push  \n- 외부 API(Instagram, FCM 등)는 BFF를 통해 호출·토큰 관리\n\n### Code Organization & Convention\n#### Domain-Driven Organization Strategy\n- Bounded Context: user, house, community, application, report  \n- Layer 분리: controller → service → repository → entity  \n- Feature-based 모듈: `apps/community`, `apps/application`  \n- Shared: `libs/common`, `libs/types`, `libs/utils`\n\n#### Universal File & Folder Structure\n```\n/repo-root\n├── apps/\n│   ├── frontend/          # Next.js\n│   │   ├── app/\n│   │   ├── components/\n│   │   ├── hooks/\n│   │   ├── lib/\n│   │   └── styles/\n│   └── api-gateway/       # NestJS BFF\n│       ├── src/\n│       │   ├── modules/\n│       │   │   ├── user/\n│       │   │   ├── community/\n│       │   │   └── project/\n│       │   ├── common/\n│       │   └── main.ts\n│       └── test/\n├── services/\n│   ├── user-service/\n│   ├── community-service/\n│   └── report-service/\n├── libs/\n│   ├── common/\n│   ├── types/\n│   └── config/\n├── infra/\n│   ├── helm/\n│   ├── terraform/\n│   └── scripts/\n└── docs/\n```\n\n### Data Flow & Communication Patterns\n- 클라이언트 ⇄ BFF: JSON REST, 인증(OAuth2 + JWT), 429 처리  \n- BFF ⇄ Microservices: gRPC(내부) + Event Bridge(비동기)  \n- Microservices ⇄ DB: TypeORM Connection Pool(50)  \n- 실시간 피드: Socket.io 네임스페이스 `/feed`, Redis Pub/Sub  \n- 외부 API: Circuit Breaker + Exponential Backoff\n\n## 4. Performance & Optimization Strategy\n- Critical CSS & 코드 스플리팅, 이미지 최적화(Next Image, AVIF)  \n- Redis 캐시·CDN 캐싱·Edge ISR로 TTFB 최소화  \n- Slow Query Log & PgBouncer로 DB 병목 제거  \n- Lighthouse·k6·Grafana RUM으로 지속적 성능 모니터링\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (M+2)\n- Core Infrastructure: EKS, CI/CD 파이프라인, 기본 Helm  \n- Essential Features: Public Site MVP, Resident 로그인/피드, Admin 회원 승인  \n- Basic Security: OAuth2, JWT, HTTPS, Helmet  \n- Dev Setup: 모노레포, Lint/Prettier, Storybook  \n- Timeline: 착수 후 2개월\n\n### Phase 2: Feature Enhancement (M+4)\n- Living Guide, 이벤트·투표, 인스타 연동, 푸시 알림  \n- Performance: Redis 도입, 퍼포먼스 튜닝 1차  \n- Enhanced Security: Rate Limiter, 2FA(Clerk)  \n- Monitoring: Prometheus·Grafana·Sentry 배포  \n- Timeline: 착수 후 4개월\n\n### Phase 3: Scaling & Optimization (M+6)\n- 멀티테넌트 구조 전환, 리포트 자동화, 권한 세분화  \n- Kubernetes HPA·VPA, Read Replica, DB 샤딩 POC  \n- PG·외부 회계 API 통합, 개인화 추천 AI SDK  \n- SOC2 대응 로깅·감사 추적 구축  \n- Timeline: 착수 후 6개월\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n| 위험 | 설명 | 대응책 |\n|------|------|-------|\n| Instagram API 변경 | Graph API 버전업·권한 제한 | RSS 백업·스크레이핑 fallback, 기능 토글 |\n| 실시간 피드 부하 | Socket.io 스케일 시 세션 문제 | Sticky Session 없는 Redis Adapter 사용 |\n| 데이터 유출 | PII 저장·전송 | AES256 at-rest, TLS1.3, 정기 Pen-Test |\n| DB 스케일 한계 | 멀티테넌트 확대 시 I/O 증가 | Read Replica, 파티셔닝, CQRS 도입 |\n\n### Project Delivery Risks\n| 위험 | 설명 | 대응책 |\n|------|------|-------|\n| 일정 지연 | 의존 모듈 복잡성 | 2주 스프린트, 버퍼 10%, MVP 우선순위 |\n| 리소스 부족 | NestJS 경험 부족 인력 | 사내 Tech-Workshop, 코드 템플릿 제공 |\n| 품질 저하 | 테스트 커버리지 미흡 | Jest E2E, Playwright UI 테스트, SonarCloud |\n| 배포 장애 | Blue/Green 실패 | Argo Rollback, DB 마이그레이션 version lock |\n\n## 끝",
      "writedAt": "2025-06-25T11:36:37.117Z"
    },
    {
      "type": "guideline",
      "content": "# 아이부키(ibookee) Unified Platform — Code Guideline\n\n---\n\n## 1. Project Overview\n\nThis project is a unified platform for ibookee, integrating the Public Site, Resident Portal, and Admin Portal into a single monorepo. The architecture is based on:\n\n- **Frontend:** Next.js 14 (App Router), React 18, TypeScript, Tailwind CSS, Shadcn UI, Zustand\n- **Backend:** Node.js 20, NestJS 10, TypeORM, PostgreSQL 15, Redis 7, Socket.io\n- **Infrastructure:** AWS EKS, RDS, S3, CloudFront, Terraform, GitHub Actions CI/CD\n- **Key Decisions:**  \n    - Monorepo (feature/domain-based) with separation between frontend and backend apps\n    - BFF (Backend-for-Frontend) pattern using NestJS API Gateway\n    - SSR/CSR hybrid with SEO, accessibility, and performance focus\n    - Multi-tenant, RBAC, and secure-by-design (OAuth2, JWT, AES256)\n\n---\n\n## 2. Core Principles\n\n1. **Explicitness:** Code MUST be self-explanatory; avoid ambiguity in logic and naming.\n2. **Single Responsibility:** Each file/function/class MUST have one clear purpose.\n3. **Consistency:** Follow established patterns and naming conventions across all modules.\n4. **Security by Default:** All code MUST handle authentication, authorization, and data validation as first-class concerns.\n5. **Testability:** All business logic MUST be unit/integration testable and covered by automated tests.\n\n---\n\n## 3. Language-Specific Guidelines\n\n### 3.1 Frontend (Next.js, React, TypeScript)\n\n#### File Organization\n\n- MUST use feature/domain-based folders under `apps/frontend/` (e.g., `/app/community/`, `/components/community/`)\n- Shared utilities, types, and hooks MUST reside in `libs/`\n- Page components go in `/app/`, UI components in `/components/`, hooks in `/hooks/`, and API logic in `/lib/`\n\n```typescript\n// apps/frontend/components/community/CommunityFeed.tsx\nexport function CommunityFeed() { ... }\n```\n\n#### Import/Dependency Management\n\n- MUST use absolute imports from project root (e.g., `import { CommunityFeed } from '@/components/community/CommunityFeed'`)\n- MUST NOT use deep relative imports (`../../../`)\n- Only import what is necessary; avoid circular dependencies.\n\n```typescript\n// MUST: Absolute import\nimport { CommunityFeed } from '@/components/community/CommunityFeed'\n```\n\n#### Error Handling\n\n- All API calls MUST use `try/catch` and handle errors gracefully in UI.\n- User-facing errors MUST be translated and accessible.\n- MUST use error boundaries for React component tree.\n\n```typescript\n// MUST: Error boundary usage\n<ErrorBoundary fallback={<ErrorMessage />}>\n  <CommunityFeed />\n</ErrorBoundary>\n```\n\n---\n\n### 3.2 Backend (NestJS, TypeScript)\n\n#### File Organization\n\n- MUST use domain-driven modules under `src/modules/` (e.g., `src/modules/user/`)\n- Shared logic in `src/common/`, DTOs in `dto/`, entities in `entities/`\n\n```typescript\n// src/modules/user/user.controller.ts\n@Controller('users')\nexport class UserController { ... }\n```\n\n#### Import/Dependency Management\n\n- MUST use NestJS Dependency Injection for services/repositories.\n- MUST NOT import modules or services directly bypassing DI.\n- Only import from `libs/` for shared code.\n\n```typescript\n// MUST: DI usage\n@Injectable()\nexport class UserService {\n  constructor(private readonly repo: UserRepository) {}\n}\n```\n\n#### Error Handling\n\n- All controller endpoints MUST use global exception filters.\n- Validation errors MUST return 400 with clear messages.\n- Sensitive errors MUST NOT be exposed to clients.\n\n```typescript\n// MUST: Use class-validator\n@UsePipes(new ValidationPipe())\n@Post()\nasync create(@Body() dto: CreateUserDto) { ... }\n```\n\n---\n\n### 3.3 Shared Libraries\n\n- All shared types and utilities MUST be placed in `libs/types/` and `libs/common/`\n- MUST version and document all shared APIs\n\n---\n\n## 4. Code Style Rules\n\n### 4.1 MUST Follow\n\n#### 1. Type Safety\n\n- All code MUST be fully typed (no `any` or implicit `any`)\n- Rationale: Prevents runtime errors and ensures maintainability\n\n```typescript\n// MUST: Typed function\nfunction getUser(id: string): Promise<User> { ... }\n```\n\n#### 2. Naming Conventions\n\n- MUST use `camelCase` for variables/functions, `PascalCase` for types/classes/components, `UPPER_SNAKE_CASE` for constants\n- Rationale: Consistent naming improves readability and onboarding\n\n```typescript\n// MUST: Naming\nconst MAX_RETRIES = 3;\nclass ResidentPortal { ... }\n```\n\n#### 3. Component Structure (React)\n\n- MUST keep components <200 lines and stateless where possible; split logic into hooks\n- Rationale: Simplifies testing and reuse\n\n```typescript\n// MUST: Use custom hook\nfunction useCommunityFeed() { ... }\nfunction CommunityFeed() {\n  const { posts } = useCommunityFeed();\n  return ( ... );\n}\n```\n\n#### 4. API Contracts\n\n- All API DTOs MUST be validated with `class-validator` (backend) or Zod (frontend)\n- Rationale: Prevents invalid data propagation\n\n```typescript\n// MUST: DTO validation\nexport class CreateUserDto {\n  @IsEmail()\n  email: string;\n}\n```\n\n#### 5. Accessibility & i18n\n\n- All UI MUST be WCAG 2.1 AA compliant and use i18n-ready text\n- Rationale: Legal and user base requirements\n\n```typescript\n// MUST: Accessible button\n<button aria-label={t('submit_application')}>{t('Apply')}</button>\n```\n\n---\n\n### 4.2 MUST NOT Do\n\n#### 1. Monolithic Files/Modules\n\n- MUST NOT combine multiple domains or responsibilities in a single file\n- Rationale: Hinders maintainability and increases merge conflicts\n\n```typescript\n// MUST NOT: Mixed logic\n// user+project+community logic in one file\n```\n\n#### 2. Implicit Any or Untyped Code\n\n- MUST NOT use `any` or omit types in TypeScript\n- Rationale: Breaks type safety\n\n```typescript\n// MUST NOT: Implicit any\nfunction handle(data) { ... }\n```\n\n#### 3. Business Logic in Controllers or UI\n\n- MUST NOT place business logic in React components or NestJS controllers; move to services/hooks\n- Rationale: Violates separation of concerns\n\n```typescript\n// MUST NOT: Logic in controller\n@Post()\ncreate(@Body() dto) {\n  // complex business logic here (BAD)\n}\n```\n\n#### 4. Complex State Management\n\n- MUST NOT introduce Redux/RTK or global state unless justified; prefer Zustand or local state\n- Rationale: Complexity and bundle size\n\n#### 5. Hardcoded Strings/Values\n\n- MUST NOT hardcode text, URLs, or config; use env variables, i18n, or config files\n\n---\n\n## 5. Architecture Patterns\n\n### 5.1 Component/Module Structure\n\n- MUST follow domain-driven, feature-based structure in both frontend and backend\n- Each module/component MUST have its own folder with index, types, and tests\n\n```typescript\n// apps/frontend/components/community/index.ts\nexport * from './CommunityFeed';\n// apps/frontend/components/community/CommunityFeed.test.tsx\n```\n\n### 5.2 Data Flow Patterns\n\n- Frontend:  \n    - Data fetching via Next.js server components or SWR/Zustand hooks\n    - All API requests MUST go through the BFF (NestJS Gateway)\n- Backend:  \n    - Controller → Service → Repository → Entity\n    - Use DTOs for input/output, never expose entities directly\n\n```typescript\n// MUST: Data flow in backend\n@Controller('projects')\nexport class ProjectController {\n  constructor(private readonly service: ProjectService) {}\n  @Get()\n  findAll() { return this.service.getAllProjects(); }\n}\n```\n\n### 5.3 State Management Conventions\n\n- MUST use Zustand for shared state; keep state shape minimal and flat\n- MUST colocate state logic with feature (not global store)\n- MUST NOT use Redux/RTK\n\n```typescript\n// MUST: Zustand store\nimport { create } from 'zustand';\nexport const useUserStore = create(set => ({\n  user: null,\n  setUser: (user) => set({ user }),\n}));\n```\n\n### 5.4 API Design Standards\n\n- RESTful endpoints, versioned (`/api/v1/`)\n- MUST use HTTP status codes correctly (200, 201, 400, 401, 403, 404, 500)\n- All endpoints MUST require authentication unless public\n- API responses MUST be consistent: `{ data, error, meta }`\n\n```typescript\n// MUST: API response DTO\nexport class ApiResponse<T> {\n  data: T;\n  error?: string;\n  meta?: Record<string, any>;\n}\n```\n\n---\n\n## Example Code Snippets\n\n```typescript\n// MUST: Typed, single-responsibility React component\nimport { useCommunityFeed } from '@/hooks/useCommunityFeed';\n\nexport function CommunityFeed() {\n  const { posts, error } = useCommunityFeed();\n  if (error) return <ErrorMessage message={error} />;\n  return <ul>{posts.map(post => <PostItem key={post.id} post={post} />)}</ul>;\n}\n// Clear separation of data-fetching (hook) and UI (component)\n```\n\n```typescript\n// MUST NOT: Business logic in component, untyped props\nfunction CommunityFeed(props) {\n  // fetch, filter, and mutate data directly here (BAD)\n  // props: any\n  ...\n}\n// This mixes concerns, is untyped, and hard to test\n```\n\n```typescript\n// MUST: NestJS service with dependency injection\n@Injectable()\nexport class CommunityService {\n  constructor(private readonly repo: CommunityRepository) {}\n  async getFeed(userId: string): Promise<Post[]> {\n    return this.repo.findByUser(userId);\n  }\n}\n// Logic is testable, isolated, and DI-compliant\n```\n\n```typescript\n// MUST NOT: Direct DB access in controller\n@Controller('community')\nexport class CommunityController {\n  @Get('feed')\n  async getFeed() {\n    // await getConnection().query('SELECT ...'); (BAD)\n  }\n}\n// Violates separation of concerns\n```\n\n```typescript\n// MUST: Error handling in API call\ntry {\n  const res = await fetch('/api/v1/community');\n  if (!res.ok) throw new Error('Failed to load');\n  const data = await res.json();\n} catch (err) {\n  setError(err.message);\n}\n// Ensures user feedback and graceful degradation\n```\n\n```typescript\n// MUST NOT: Silent failure or unhandled promise\nfetch('/api/v1/community').then(res => res.json()).then(setData);\n// No error handling; user may see blank screen on failure\n```\n\n---\n\n## Quality Criteria\n\n- **Specificity:** All rules are tailored to Next.js, React, NestJS, and TypeScript.\n- **Actionability:** Each rule is accompanied by rationale and example.\n- **Consistency:** Naming, structure, and data flow are uniform across the codebase.\n- **Practicality:** Rules avoid over-engineering and are feasible for all contributors.\n- **Security & Accessibility:** Authentication, validation, and WCAG/i18n are first-class requirements.\n\n---\n\n**This guideline is the authoritative reference for all code in the ibookee unified platform project. All contributors MUST adhere to these standards for every commit and code review.**",
      "writedAt": "2025-06-25T11:36:37.117Z"
    }
  ]
}